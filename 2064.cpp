#include<iostream>
#include<cstdio>
using namespace std;
/*
杭电acm2064
汉诺塔III
Problem Description
约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。
现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。
Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？

Input
包含多组数据，每次输入一个N值(1<=N=35)。
Output
对于每组数据，输出移动最小的次数。
Sample Input
1
3
12
Sample Output
2
26
531440

注意这一个题目的改编！！
 
做过汉诺塔的应该非常熟悉，那此题非常简单了，
就是一个规律题，题目改动是改成了只能一下一下走，
不能跨一个杆子，所以算出a[1]=2,a[2]=8,a[3]=26,a[4]=80,可以看出从2开始都满足a[n]=3*a[n-1]+2，再把这个码打出代入12看看是不是Sample Output的531440，得出结果是，那更加确定了，所以解出此题
――――――――――――――――
版权声明：本文为CSDN博主「v_coco」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43263426/article/details/85417767
*/
int main(){
	int n;
	long long int arr[40]={0,2};
	arr[1]=2;
	arr[2]=2;
	for(int i=2;i<40;i++){
		arr[i]=3*arr[i-1]+2;
	}
	while(cin>>n){
		if(n==1)cout<<2<<endl;
		else
			cout<<arr[n]<<endl;
	}
	return 0;
}
